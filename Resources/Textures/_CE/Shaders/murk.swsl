uniform sampler2D SCREEN_TEXTURE;
uniform highp float baseIntensity;
uniform highp vec2 playerPos;
uniform lowp int count;
uniform highp vec2[64] position;
uniform highp float[64] intensities;
uniform highp vec2 renderScale;
uniform highp vec3 shaderColor;

const highp float noiseDistortion = 300.0;
const highp float noiseScale = 5.0;
const highp float timeScale = 0.1;

highp vec3 randZ(highp vec2 p) {
    return fract(sin(vec3(dot(p, vec2(127.1,311.7)), dot(p, vec2(269.5,183.3)), dot(p, vec2(419.2,371.9))))*43758.5453);
}

highp float noise(highp vec2 p) {
    const highp float K1=0.366025404, K2=0.211324865;
    highp vec2 i = floor(p + (p.x+p.y)*K1);
    highp vec2 a = p - i + (i.x+i.y)*K2;
    highp vec2 o = vec2(step(a.y,a.x), 1.0-step(a.y,a.x));
    highp vec2 b = a - o + K2, c = a - 1.0 + 2.0*K2;
    highp vec3 h = max(0.5-vec3(dot(a,a),dot(b,b),dot(c,c)),0.0);
    highp vec3 n = h*h*h*h * vec3(dot(a,randZ(i).xy), dot(b,randZ(i+o).xy), dot(c,randZ(i+1.0).xy));
    return dot(n, vec3(70.0));
}

highp float murk(highp vec2 fragPos) {
    highp float total = baseIntensity, scale = renderScale.x;
    for (lowp int i=0;i<min(count,64);i++) {
        highp float intensity = intensities[i];
        if(intensity==0.0) continue;
        highp float r=abs(intensity)*33.0*scale, d=length(fragPos-position[i]);
        if(d<=r) total += intensity*(1.0-d/r);
    }
    return total;
}

highp vec3 gradient(highp float t) {
    return mix(vec3(0.0), vec3(0.025,0.054,0.042), t);
}

void fragment() {
    highp vec2 uv = FRAGCOORD.xy * SCREEN_PIXEL_SIZE;
    highp vec2 nUV = (uv + playerPos*0.05)*noiseScale + TIME*timeScale;
    highp vec2 d = (vec2(noise(nUV+vec2(3.1,7.7)), noise(nUV+vec2(9.3,2.4)))-0.5)*noiseDistortion;

    highp float v = clamp(1.0 - (murk(FRAGCOORD.xy + d)*0.5+0.5),0.2,1.0);
    highp float desat = v>0.5 ? 0.0 : v>0.4 ? smoothstep(0.5,0.4,v) : 1.0;

    highp vec3 color = mix(gradient(noise(nUV)), zTextureSpec(SCREEN_TEXTURE, uv).rgb, v);

    COLOR = vec4(color,1.0);
}
