uniform sampler2D SCREEN_TEXTURE;
uniform highp float baseIntensity;
uniform highp vec2 playerPos;
uniform lowp int count;
uniform highp vec2[64] position;
uniform highp float[64] intensities;
uniform highp vec2 renderScale;
uniform highp vec3 shaderColor;

const highp float noiseDistortion = 100.0;
const highp float noiseScale = 4.0;
const highp float timeScale = 0.123;

highp vec3 randZ(highp vec2 p) {
    return fract(sin(vec3(dot(p, vec2(127.1,311.7)), dot(p, vec2(269.5,183.3)), dot(p, vec2(419.2,371.9))))*43758.5453);
}

highp float noise(highp vec2 p) {
    const highp float K1=0.366025404, K2=0.211324865;
    highp vec2 i = floor(p + (p.x+p.y)*K1);
    highp vec2 a = p - i + (i.x+i.y)*K2;
    highp vec2 o = vec2(step(a.y,a.x), 1.0-step(a.y,a.x));
    highp vec2 b = a - o + K2, c = a - 1.0 + 2.0*K2;
    highp vec3 h = max(0.5-vec3(dot(a,a),dot(b,b),dot(c,c)),0.0);
    highp vec3 n = h*h*h*h * vec3(dot(a,randZ(i).xy), dot(b,randZ(i+o).xy), dot(c,randZ(i+1.0).xy));
    return dot(n, vec3(70.0));
}

highp float murk(highp vec2 fragPos) {
    highp float total = baseIntensity;
    highp float scale = renderScale.x;
    for (lowp int i = 0; i < min(count, 64); i++) {
        highp float intensity = intensities[i];
        if (intensity == 0.0) continue;
        highp float r = abs(intensity) * 33.0 * scale;
        highp float d = length(fragPos - position[i]);
        if (d <= r) total += intensity * (1.0 - d / r);
    }
    return total;
}

highp vec3 gradient(highp float t) {
    return mix(vec3(0.0), vec3(0.025, 0.032, 0.054), t);
}

void fragment() {
    highp vec2 uv = FRAGCOORD.xy * SCREEN_PIXEL_SIZE;
    highp vec2 nUV = (uv + playerPos * 0.05) * noiseScale + TIME * timeScale;
    highp vec2 d = (vec2(noise(nUV + vec2(3.1, 7.7)), noise(nUV + vec2(9.3, 2.4))) - 0.5) * noiseDistortion;

    // Основная видимость
    highp float visibility = clamp(1.0 - (murk(FRAGCOORD.xy + d) * 0.5 + 0.5), 0.2, 1.0);

    // Рассчитываем силу "обводки" по границе света и тьмы
    highp float outline = smoothstep(0.2, 0.4, visibility) - smoothstep(0.35, 0.4, visibility);
    highp vec3 outlineColor = vec3(0.25, 0.32, 0.54);

    highp vec3 sceneColor = texture(SCREEN_TEXTURE, uv).rgb;
    highp vec3 murkColor = gradient(noise(nUV));
    highp vec3 mixedColor = mix(murkColor, sceneColor, visibility);

    mixedColor += outlineColor * outline;

    COLOR = vec4(mixedColor, 1.0);
}
