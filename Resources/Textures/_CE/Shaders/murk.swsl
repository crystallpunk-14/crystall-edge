uniform sampler2D SCREEN_TEXTURE;

uniform highp float baseIntensity;
uniform highp vec2 playerPos;
uniform lowp int count;
uniform highp vec2[64] position;
uniform highp float[64] intensities;

uniform highp vec2 renderScale;
uniform highp vec3 shaderColor;

const highp float noiseDistortion = 200.0;
const highp float desaturationDistance = 0.1;
const highp float noiseScale = 4.0;
const highp float timeScale = 0;

highp float noise(highp vec2 p) {
    const highp float K1 = 0.366025404;
    const highp float K2 = 0.211324865;
    highp vec2 i = floor(p + (p.x + p.y) * K1);
    highp vec2 a = p - i + (i.x + i.y) * K2;
    highp float m = step(a.y, a.x);
    highp vec2 o = vec2(m, 1.0 - m);
    highp vec2 b = a - o + K2;
    highp vec2 c = a - 1.0 + 2.0 * K2;
    highp vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);
    highp vec3 n = h * h * h * h * vec3(
        dot(a, zRandom(i)),
        dot(b, zRandom(i + o)),
        dot(c, zRandom(i + 1.0))
    );
    return dot(n, vec3(70.0));
}

highp vec3 gradientColor(highp float t) {
    return mix(vec3(0.0), vec3(0.003, 0.003, 0.005), t * 2.0);
}

highp float calculateMurkLevelAtPoint(highp vec2 fragPos) {
    highp float total = baseIntensity;
    highp float scale = renderScale.x;

    for (lowp int i = 0; i < min(count, 64); i++) {
        highp float intensity = intensities[i];
        if (intensity == 0.0) continue;

        highp float radius = abs(intensity) * 33.0 * scale;
        highp float dist = length(fragPos - position[i]);

        if (dist <= radius)
            total += intensity * (1.0 - dist / radius);
    }
    return total;
}

highp vec3 desaturateByDistance(highp vec3 color, highp float murkLevel) {
    highp float factor = clamp(murkLevel / desaturationDistance, 0.0, 1.0);
    highp float gray = dot(color, vec3(0.299, 0.587, 0.114));
    return mix(color, vec3(gray), factor);
}

void fragment() {
    highp vec2 fragPos = FRAGCOORD.xy;
    highp vec2 playerOffset = playerPos;
    highp vec2 uv = fragPos * SCREEN_PIXEL_SIZE;
    highp float t = TIME * timeScale;

    highp vec2 noiseUV = (uv + playerOffset * 0.06) * noiseScale + vec2(t);
    highp float n = noise(noiseUV);
    highp vec3 colorOverlay = gradientColor(n);

    highp vec2 distortion = vec2(
        noise(noiseUV + vec2(3.1, 7.7)),
        noise(noiseUV + vec2(9.3, 2.4))
    ) - 0.5;
    distortion *= noiseDistortion;

    highp float murk = calculateMurkLevelAtPoint(fragPos + distortion);
    highp float visibility = clamp(1.0 - (murk * 0.5 + 0.5), 0.0, 1.0);

    highp vec3 baseColor = zTextureSpec(SCREEN_TEXTURE, uv).rgb;
    highp vec3 finalColor = mix(colorOverlay, baseColor, visibility);
    finalColor = desaturateByDistance(finalColor, murk);

    COLOR = vec4(finalColor, 1.0);
}
