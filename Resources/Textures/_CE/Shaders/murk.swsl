uniform sampler2D SCREEN_TEXTURE;

uniform highp float baseIntensity;
uniform highp vec2 playerPos;
uniform lowp int count;
uniform highp vec2[64] position;
uniform highp float[64] intensities;

uniform highp vec2 renderScale;
uniform highp vec3 shaderColor;

const highp float noiseDistortion = 100.0;
const highp float desaturationDistance = 0.1;
const highp float noiseScale = 5.0;
const highp float secondNoiseScale = 40.0;
const highp float timeScale = 0.1;

highp vec3 randomizeZ(highp vec2 p) {
    return fract(sin(vec3(dot(p, vec2(127.1, 311.7)),
                          dot(p, vec2(269.5, 183.3)),
                          dot(p, vec2(419.2, 371.9)))) * 43758.5453);
}

highp float noise(highp vec2 p) {
    const highp float K1 = 0.366025404;
    const highp float K2 = 0.211324865;
    highp vec2 i = floor(p + (p.x + p.y) * K1);
    highp vec2 a = p - i + (i.x + i.y) * K2;
    highp float m = step(a.y, a.x);
    highp vec2 o = vec2(m, 1.0 - m);
    highp vec2 b = a - o + K2;
    highp vec2 c = a - 1.0 + 2.0 * K2;
    highp vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);
    highp vec3 n = h * h * h * h * vec3(
        dot(a, randomizeZ(i).xy),
        dot(b, randomizeZ(i + o).xy),
        dot(c, randomizeZ(i + 1.0).xy)
    );
    return dot(n, vec3(70.0));
}

highp vec3 gradientColor(highp float t) {
    return mix(vec3(0.0), vec3(0.003, 0.003, 0.005), t * 2.0);
}

highp float calculateMurkLevelAtPoint(highp vec2 fragPos) {
    highp float total = baseIntensity;
    highp float scale = renderScale.x;

    for (lowp int i = 0; i < min(count, 64); i++) {
        highp float intensity = intensities[i];
        if (intensity == 0.0) continue;

        highp float radius = abs(intensity) * 33.0 * scale;
        highp float dist = length(fragPos - position[i]);

        if (dist <= radius)
            total += intensity * (1.0 - dist / radius);
    }
    return total;
}

highp vec3 desaturate(highp vec3 color, highp float factor) {
    highp float gray = dot(color, vec3(0.299, 0.587, 0.114));
    return mix(color, vec3(gray), factor);
}

void fragment() {
    highp vec2 fragPos = FRAGCOORD.xy;
    highp vec2 playerOffset = playerPos;
    highp vec2 uv = fragPos * SCREEN_PIXEL_SIZE;
    highp float t = TIME * timeScale;

    highp vec2 noiseUV = (uv + playerOffset * 0.06) * noiseScale + vec2(t);
    highp float n = noise(noiseUV);
    highp vec3 colorOverlay = gradientColor(n);

    highp vec2 distortion = vec2(
        noise(noiseUV + vec2(3.1, 7.7)),
        noise(noiseUV + vec2(9.3, 2.4))
    ) - 0.5;
    distortion *= noiseDistortion;

    highp float murk = calculateMurkLevelAtPoint(fragPos + distortion);
    highp float visibility = clamp(1.0 - (murk * 0.5 + 0.5), 0.0, 1.0);

    visibility = max(visibility, 0.2);

    highp float desatFactor = 0.0;
    if (visibility > 0.5) {
        desatFactor = 0.0;
    } else if (visibility > 0.4) {
        desatFactor = smoothstep(0.5, 0.4, visibility);
    } else {
        desatFactor = 1.0;
    }

    highp vec3 baseColor = zTextureSpec(SCREEN_TEXTURE, uv).rgb;
    baseColor = mix(colorOverlay, baseColor, visibility);
    baseColor = desaturate(baseColor, desatFactor);

    baseColor *= visibility;

    COLOR = vec4(baseColor, 1);
}
