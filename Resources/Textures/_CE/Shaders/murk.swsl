uniform sampler2D SCREEN_TEXTURE;
uniform highp float baseIntensity;
uniform highp vec2 playerPos;
uniform lowp int count;
uniform highp vec2[64] position;
uniform highp float[64] intensities;
uniform highp vec2 renderScale;
uniform highp vec3 shaderColor;

const highp float noiseOffsetStrength = 100.0;
const highp float noiseFrequency = 4.0;
const highp float noiseTimeSpeed = 0.123;

highp vec3 randomVector(highp vec2 coord) {
    return fract(sin(vec3(dot(coord, vec2(127.1,311.7)), dot(coord, vec2(269.5,183.3)), dot(coord, vec2(419.2,371.9))))*43758.5453);
}

highp float simplexNoise(highp vec2 coord) {
    const highp float K1=0.366025404, K2=0.211324865;
    highp vec2 i = floor(coord + (coord.x+coord.y)*K1);
    highp vec2 a = coord - i + (i.x+i.y)*K2;
    highp vec2 offset = vec2(step(a.y,a.x), 1.0-step(a.y,a.x));
    highp vec2 b = a - offset + K2, c = a - 1.0 + 2.0*K2;
    highp vec3 h = max(0.5-vec3(dot(a,a),dot(b,b),dot(c,c)),0.0);
    highp vec3 n = h*h*h*h * vec3(dot(a,randomVector(i).xy), dot(b,randomVector(i+offset).xy), dot(c,randomVector(i+1.0).xy));
    return dot(n, vec3(70.0));
}

highp float calculateDarkness(highp vec2 pixelPosition) {
    highp float accumulated = baseIntensity;
    highp float scale = renderScale.x;
    for (lowp int i = 0; i < min(count, 64); i++) {
        highp float sourceIntensity = intensities[i];
        if (sourceIntensity == 0.0) continue;
        highp float radius = abs(sourceIntensity) * 33.0 * scale;
        highp float distanceToLight = length(pixelPosition - position[i]);
        if (distanceToLight <= radius) accumulated += sourceIntensity * (1.0 - distanceToLight / radius);
    }
    return accumulated;
}

highp vec3 darknessGradient(highp float factor) {
    return mix(vec3(0.0), vec3(0.025, 0.032, 0.054), factor);
}

void fragment() {
    highp vec2 screenUV = FRAGCOORD.xy * SCREEN_PIXEL_SIZE;
    highp vec2 noiseCoord = (screenUV + playerPos * 0.05) * noiseFrequency + TIME * noiseTimeSpeed;
    highp vec2 noiseDistortionVec = (vec2(simplexNoise(noiseCoord + vec2(3.1, 7.7)), simplexNoise(noiseCoord + vec2(9.3, 2.4))) - 0.5) * noiseOffsetStrength;

    highp float visibility = clamp(1.0 - calculateDarkness(FRAGCOORD.xy + noiseDistortionVec), 0.1, 1.0);


    highp vec3 originalScene = texture(SCREEN_TEXTURE, screenUV).rgb;
    highp vec3 fogGradient = darknessGradient(simplexNoise(noiseCoord));
    highp vec3 finalColor = mix(fogGradient, originalScene, visibility);

    //highp float outlineStrength = smoothstep(0.2, 0.4, visibility) - smoothstep(0.35, 0.4, visibility);
    //highp vec3 outlineTint = vec3(0.25, 0.32, 0.54);
    //finalColor += outlineTint * outlineStrength;

    COLOR = vec4(finalColor, 1.0);
}
